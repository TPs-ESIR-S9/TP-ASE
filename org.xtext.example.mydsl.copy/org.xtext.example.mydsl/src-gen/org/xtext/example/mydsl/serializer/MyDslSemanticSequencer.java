/*
 * generated by Xtext 2.31.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;
import roboML.ArithmeticExpression;
import roboML.Assignement;
import roboML.Condition;
import roboML.Deplacement;
import roboML.Entity;
import roboML.Function;
import roboML.FunctionCall;
import roboML.GetValue;
import roboML.Loop;
import roboML.RoboMLPackage;
import roboML.RoboMLProgram;
import roboML.Rotation;
import roboML.SetValue;
import roboML.Unit;
import roboML.Variable;
import roboML.VariableRef;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RoboMLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RoboMLPackage.ARITHMETIC_EXPRESSION:
				sequence_ArithmeticExpression(context, (ArithmeticExpression) semanticObject); 
				return; 
			case RoboMLPackage.ASSIGNEMENT:
				sequence_Assignement(context, (Assignement) semanticObject); 
				return; 
			case RoboMLPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case RoboMLPackage.DEPLACEMENT:
				sequence_Deplacement(context, (Deplacement) semanticObject); 
				return; 
			case RoboMLPackage.ENTITY:
				sequence_Entity_Impl(context, (Entity) semanticObject); 
				return; 
			case RoboMLPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case RoboMLPackage.FUNCTION_CALL:
				sequence_FunctionCall(context, (FunctionCall) semanticObject); 
				return; 
			case RoboMLPackage.GET_VALUE:
				sequence_GetValue(context, (GetValue) semanticObject); 
				return; 
			case RoboMLPackage.LOOP:
				sequence_Loop(context, (Loop) semanticObject); 
				return; 
			case RoboMLPackage.ROBO_ML_PROGRAM:
				sequence_RoboMLProgram(context, (RoboMLProgram) semanticObject); 
				return; 
			case RoboMLPackage.ROTATION:
				sequence_Rotation(context, (Rotation) semanticObject); 
				return; 
			case RoboMLPackage.SET_VALUE:
				sequence_SetValue(context, (SetValue) semanticObject); 
				return; 
			case RoboMLPackage.UNIT:
				sequence_Unit(context, (Unit) semanticObject); 
				return; 
			case RoboMLPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case RoboMLPackage.VARIABLE_REF:
				sequence_VariableRef(context, (VariableRef) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Entity returns ArithmeticExpression
	 *     ArithmeticExpression returns ArithmeticExpression
	 *
	 * Constraint:
	 *     (
	 *         entityType=RMLObject? 
	 *         arithmeticOperator=ArithmeticOperators? 
	 *         elementA=[Entity|EString] 
	 *         elementB=[Entity|EString]? 
	 *         (variable+=Variable variable+=Variable*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_ArithmeticExpression(ISerializationContext context, ArithmeticExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Assignement
	 *     Assignement returns Assignement
	 *
	 * Constraint:
	 *     (assignableVariable=[Variable|EString]? entity=[Entity|EString])
	 * </pre>
	 */
	protected void sequence_Assignement(ISerializationContext context, Assignement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Condition
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (
	 *         booleanExpression=[Entity|EString]? 
	 *         (statementIf+=Statement statementIf+=Statement*)? 
	 *         (statementElse+=Statement statementElse+=Statement*)? 
	 *         (variable+=Variable variable+=Variable*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Deplacement
	 *     Deplacement returns Deplacement
	 *
	 * Constraint:
	 *     (movementType=Direction? unit=[Unit|EString] deplacementDistance=[Entity|EString]?)
	 * </pre>
	 */
	protected void sequence_Deplacement(ISerializationContext context, Deplacement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Entity returns Entity
	 *     Entity_Impl returns Entity
	 *
	 * Constraint:
	 *     entityType=RMLObject?
	 * </pre>
	 */
	protected void sequence_Entity_Impl(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Entity returns FunctionCall
	 *     FunctionCall returns FunctionCall
	 *
	 * Constraint:
	 *     (entityType=RMLObject? function=[Function|EString])
	 * </pre>
	 */
	protected void sequence_FunctionCall(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (newAttribute=RMLObject? returnType=RMLObject? (instruction+=Statement instruction+=Statement*)? (variable+=Variable variable+=Variable*)?)
	 * </pre>
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Entity returns GetValue
	 *     GetValue returns GetValue
	 *
	 * Constraint:
	 *     entityType=RMLObject?
	 * </pre>
	 */
	protected void sequence_GetValue(ISerializationContext context, GetValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Loop
	 *     Loop returns Loop
	 *
	 * Constraint:
	 *     (booleanExpression=[Entity|EString]? (instruction+=Statement instruction+=Statement*)? (variable+=Variable variable+=Variable*)?)
	 * </pre>
	 */
	protected void sequence_Loop(ISerializationContext context, Loop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RoboMLProgram returns RoboMLProgram
	 *
	 * Constraint:
	 *     (function+=Function function+=Function*)?
	 * </pre>
	 */
	protected void sequence_RoboMLProgram(ISerializationContext context, RoboMLProgram semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Rotation
	 *     Rotation returns Rotation
	 *
	 * Constraint:
	 *     (rotationAngle=[Entity|EString] rotationSens=[Entity|EString])
	 * </pre>
	 */
	protected void sequence_Rotation(ISerializationContext context, Rotation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RoboMLPackage.Literals.ROTATION__ROTATION_ANGLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoboMLPackage.Literals.ROTATION__ROTATION_ANGLE));
			if (transientValues.isValueTransient(semanticObject, RoboMLPackage.Literals.ROTATION__ROTATION_SENS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoboMLPackage.Literals.ROTATION__ROTATION_SENS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRotationAccess().getRotationAngleEntityEStringParserRuleCall_3_0_1(), semanticObject.eGet(RoboMLPackage.Literals.ROTATION__ROTATION_ANGLE, false));
		feeder.accept(grammarAccess.getRotationAccess().getRotationSensEntityEStringParserRuleCall_5_0_1(), semanticObject.eGet(RoboMLPackage.Literals.ROTATION__ROTATION_SENS, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns SetValue
	 *     SetValue returns SetValue
	 *
	 * Constraint:
	 *     entityToSet=[Entity|EString]
	 * </pre>
	 */
	protected void sequence_SetValue(ISerializationContext context, SetValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RoboMLPackage.Literals.SET_VALUE__ENTITY_TO_SET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RoboMLPackage.Literals.SET_VALUE__ENTITY_TO_SET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetValueAccess().getEntityToSetEntityEStringParserRuleCall_3_0_1(), semanticObject.eGet(RoboMLPackage.Literals.SET_VALUE__ENTITY_TO_SET, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Unit returns Unit
	 *
	 * Constraint:
	 *     Type=UnitMeasure?
	 * </pre>
	 */
	protected void sequence_Unit(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Entity returns VariableRef
	 *     VariableRef returns VariableRef
	 *
	 * Constraint:
	 *     entityType=RMLObject?
	 * </pre>
	 */
	protected void sequence_VariableRef(ISerializationContext context, VariableRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (variableName=RMLObject? variableValue=RMLObject? (variableref+=VariableRef variableref+=VariableRef*)?)
	 * </pre>
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
