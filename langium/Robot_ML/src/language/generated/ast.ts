/******************************************************************************
 * This file was generated by langium-cli 2.0.1.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import type { AstNode, Reference, ReferenceInfo, TypeMetaData } from 'langium';
import { AbstractAstReflection } from 'langium';

export const RoboMlTerminals = {
    ID: /(\^?(([a-z]|[A-Z])|_)((([a-z]|[A-Z])|_)|[0-9])*)/,
    INT: /[0-9]+/,
    STRING: /(("((\\([\s\S]))|((?!(\\|"))[\s\S]*?))*")|('((\\([\s\S]))|((?!(\\|'))[\s\S]*?))*'))/,
    ML_COMMENT: /(\/\*([\s\S]*?\*\/))/,
    SL_COMMENT: /(\/\/((?!(\n|\r))[\s\S]*?)(\r?\n)?)/,
    WS: /((( |	)|\r)|\n)+/,
};

export type ArithmeticOperators = ArithmeticOperators_Divide | ArithmeticOperators_Minus | ArithmeticOperators_Modulo | ArithmeticOperators_Multiplie | ArithmeticOperators_Plus | ArithmeticOperators_Power;

export type ArithmeticOperators_Divide = 'Divide';

export type ArithmeticOperators_Minus = 'Minus';

export type ArithmeticOperators_Modulo = 'Modulo';

export type ArithmeticOperators_Multiplie = 'Multiplie';

export type ArithmeticOperators_Plus = 'Plus';

export type ArithmeticOperators_Power = 'Power';

export type Direction = Direction_backward | Direction_forward | Direction_sideLeft | Direction_sideRight;

export type Direction_backward = 'Backward';

export type Direction_forward = 'Forward';

export type Direction_sideLeft = 'SideLeft';

export type Direction_sideRight = 'SideRight';

export type EString = string;

export function isEString(item: unknown): item is EString {
    return (typeof item === 'string' && (/(("((\\([\s\S]))|((?!(\\|"))[\s\S]*?))*")|('((\\([\s\S]))|((?!(\\|'))[\s\S]*?))*'))/.test(item) || /(\^?(([a-z]|[A-Z])|_)((([a-z]|[A-Z])|_)|[0-9])*)/.test(item)));
}

export type RMLObject = RMLObject_RMLBoolean | RMLObject_RMLDouble | RMLObject_RMLFloat | RMLObject_RMLInt | RMLObject_RMLString;

export type RMLObject_RMLBoolean = 'RMLBoolean';

export type RMLObject_RMLDouble = 'RMLDouble';

export type RMLObject_RMLFloat = 'RMLFloat';

export type RMLObject_RMLInt = 'RMLInt';

export type RMLObject_RMLString = 'RMLString';

export type Rotation_antiClock = 'AntiClock';

export type Rotation_clock = 'Clock';

export type RotationSens = Rotation_antiClock | Rotation_clock;

export type UnitMeasure = UnitMeasure_cm | UnitMeasure_dm | UnitMeasure_m | UnitMeasure_mm;

export type UnitMeasure_cm = 'cm';

export type UnitMeasure_dm = 'dm';

export type UnitMeasure_m = 'm';

export type UnitMeasure_mm = 'mm';

export interface Entry extends AstNode {
    readonly $type: 'ArithmeticExpression' | 'Entry' | 'EntrySimple' | 'FunctionCall' | 'GetSpeed' | 'VariableRef';
}

export const Entry = 'Entry';

export function isEntry(item: unknown): item is Entry {
    return reflection.isInstance(item, Entry);
}

export interface FunctionDec extends AstNode {
    readonly $container: RoboMLProgram;
    readonly $type: 'FunctionDec';
    functionName: string
    instruction: Array<Statement>
    returnType?: RMLObject
    variableFunDef: Array<VariableFunDef>
}

export const FunctionDec = 'FunctionDec';

export function isFunctionDec(item: unknown): item is FunctionDec {
    return reflection.isInstance(item, FunctionDec);
}

export interface RoboMLProgram extends AstNode {
    readonly $type: 'RoboMLProgram';
    function: Array<FunctionDec>
}

export const RoboMLProgram = 'RoboMLProgram';

export function isRoboMLProgram(item: unknown): item is RoboMLProgram {
    return reflection.isInstance(item, RoboMLProgram);
}

export interface Statement extends AstNode {
    readonly $type: 'Assignement' | 'Condition' | 'Deplacement' | 'Loop' | 'Rotation' | 'SetSpeed' | 'Statement';
}

export const Statement = 'Statement';

export function isStatement(item: unknown): item is Statement {
    return reflection.isInstance(item, Statement);
}

export interface Unit extends AstNode {
    readonly $type: 'Unit';
    Type?: UnitMeasure
}

export const Unit = 'Unit';

export function isUnit(item: unknown): item is Unit {
    return reflection.isInstance(item, Unit);
}

export interface VariableDef extends AstNode {
    readonly $type: 'VariableDef';
    variableName: string
    variableType: RMLObject
    variableValue: RMLObject
}

export const VariableDef = 'VariableDef';

export function isVariableDef(item: unknown): item is VariableDef {
    return reflection.isInstance(item, VariableDef);
}

export interface VariableFunDef extends AstNode {
    readonly $container: FunctionDec;
    readonly $type: 'VariableFunDef';
    variableName: string
    variableType: RMLObject
}

export const VariableFunDef = 'VariableFunDef';

export function isVariableFunDef(item: unknown): item is VariableFunDef {
    return reflection.isInstance(item, VariableFunDef);
}

export interface ArithmeticExpression extends Entry {
    readonly $type: 'ArithmeticExpression';
    arithmeticOperator?: ArithmeticOperators
    elementA: Entry
    elementB?: Entry
}

export const ArithmeticExpression = 'ArithmeticExpression';

export function isArithmeticExpression(item: unknown): item is ArithmeticExpression {
    return reflection.isInstance(item, ArithmeticExpression);
}

export interface EntrySimple extends Entry {
    readonly $type: 'EntrySimple';
}

export const EntrySimple = 'EntrySimple';

export function isEntrySimple(item: unknown): item is EntrySimple {
    return reflection.isInstance(item, EntrySimple);
}

export interface FunctionCall extends Entry {
    readonly $type: 'FunctionCall';
    arguments: Array<Entry>
    function: Reference<FunctionDec>
}

export const FunctionCall = 'FunctionCall';

export function isFunctionCall(item: unknown): item is FunctionCall {
    return reflection.isInstance(item, FunctionCall);
}

export interface GetSpeed extends Entry {
    readonly $type: 'GetSpeed';
}

export const GetSpeed = 'GetSpeed';

export function isGetSpeed(item: unknown): item is GetSpeed {
    return reflection.isInstance(item, GetSpeed);
}

export interface VariableRef extends Entry {
    readonly $type: 'VariableRef';
    VariableDef: Reference<VariableDef>
}

export const VariableRef = 'VariableRef';

export function isVariableRef(item: unknown): item is VariableRef {
    return reflection.isInstance(item, VariableRef);
}

export interface Assignement extends Statement {
    readonly $type: 'Assignement';
    assignableVariable?: Reference<VariableRef>
    entry: Entry
}

export const Assignement = 'Assignement';

export function isAssignement(item: unknown): item is Assignement {
    return reflection.isInstance(item, Assignement);
}

export interface Condition extends Statement {
    readonly $type: 'Condition';
    booleanExpression?: Entry
    statementElse: Array<Statement>
    statementIf: Array<Statement>
}

export const Condition = 'Condition';

export function isCondition(item: unknown): item is Condition {
    return reflection.isInstance(item, Condition);
}

export interface Deplacement extends Statement {
    readonly $type: 'Deplacement';
    deplacementDistance?: number
    movementType?: Direction
    unitMeasure: UnitMeasure
}

export const Deplacement = 'Deplacement';

export function isDeplacement(item: unknown): item is Deplacement {
    return reflection.isInstance(item, Deplacement);
}

export interface Loop extends Statement {
    readonly $type: 'Loop';
    booleanExpression?: Entry
    instruction: Array<Statement>
}

export const Loop = 'Loop';

export function isLoop(item: unknown): item is Loop {
    return reflection.isInstance(item, Loop);
}

export interface Rotation extends Statement {
    readonly $type: 'Rotation';
    rotationAngle: number
    rotationSens: RotationSens
}

export const Rotation = 'Rotation';

export function isRotation(item: unknown): item is Rotation {
    return reflection.isInstance(item, Rotation);
}

export interface SetSpeed extends Statement {
    readonly $type: 'SetSpeed';
    unitMeasure: UnitMeasure
    variableValue: number
}

export const SetSpeed = 'SetSpeed';

export function isSetSpeed(item: unknown): item is SetSpeed {
    return reflection.isInstance(item, SetSpeed);
}

export type RoboMlAstType = {
    ArithmeticExpression: ArithmeticExpression
    Assignement: Assignement
    Condition: Condition
    Deplacement: Deplacement
    Entry: Entry
    EntrySimple: EntrySimple
    FunctionCall: FunctionCall
    FunctionDec: FunctionDec
    GetSpeed: GetSpeed
    Loop: Loop
    RoboMLProgram: RoboMLProgram
    Rotation: Rotation
    SetSpeed: SetSpeed
    Statement: Statement
    Unit: Unit
    VariableDef: VariableDef
    VariableFunDef: VariableFunDef
    VariableRef: VariableRef
}

export class RoboMlAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['ArithmeticExpression', 'Assignement', 'Condition', 'Deplacement', 'Entry', 'EntrySimple', 'FunctionCall', 'FunctionDec', 'GetSpeed', 'Loop', 'RoboMLProgram', 'Rotation', 'SetSpeed', 'Statement', 'Unit', 'VariableDef', 'VariableFunDef', 'VariableRef'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case ArithmeticExpression:
            case EntrySimple:
            case FunctionCall:
            case GetSpeed:
            case VariableRef: {
                return this.isSubtype(Entry, supertype);
            }
            case Assignement:
            case Condition:
            case Deplacement:
            case Loop:
            case Rotation:
            case SetSpeed: {
                return this.isSubtype(Statement, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Assignement:assignableVariable': {
                return VariableRef;
            }
            case 'FunctionCall:function': {
                return FunctionDec;
            }
            case 'VariableRef:VariableDef': {
                return VariableDef;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'FunctionDec': {
                return {
                    name: 'FunctionDec',
                    mandatory: [
                        { name: 'instruction', type: 'array' },
                        { name: 'variableFunDef', type: 'array' }
                    ]
                };
            }
            case 'RoboMLProgram': {
                return {
                    name: 'RoboMLProgram',
                    mandatory: [
                        { name: 'function', type: 'array' }
                    ]
                };
            }
            case 'FunctionCall': {
                return {
                    name: 'FunctionCall',
                    mandatory: [
                        { name: 'arguments', type: 'array' }
                    ]
                };
            }
            case 'Condition': {
                return {
                    name: 'Condition',
                    mandatory: [
                        { name: 'statementElse', type: 'array' },
                        { name: 'statementIf', type: 'array' }
                    ]
                };
            }
            case 'Loop': {
                return {
                    name: 'Loop',
                    mandatory: [
                        { name: 'instruction', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new RoboMlAstReflection();
